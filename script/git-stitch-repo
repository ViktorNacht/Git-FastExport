#!/usr/bin/env perl
use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use Git::FastExport::Stitch;
use File::Spec::Functions qw( rel2abs );

our $VERSION = $Git::FastExport::Stitch::VERSION;

# basic command-line options
my %option;
GetOptions( \%option, 'help', 'manual', 'version', 'select=s', 'cached!' )
    or pod2usage( -verbose => 0 );
print "git-stitch-repo version $VERSION\n" and exit if $option{version};
pod2usage( -verbose => 1 ) if $option{help};
pod2usage( -verbose => 2 ) if $option{manual};

my $export = Git::FastExport::Stitch->new( \%option );

# process command-line parameters
while (@ARGV) {
    my ( $repo, $dir ) = split /:/, shift @ARGV, 2;
    $repo = rel2abs($repo);
    $dir ||= '';

    # add the repository to the list of repositories to stitch
    $export->stitch( $repo => $dir );
}

# run the stitching algorithm
while ( my $block = $export->next_block() ) {
    print $block->as_string;
}

__END__

=head1 NAME

git-stitch-repo - Stitch several git repositories into a git-fast-import stream

=head1 SYNOPSIS

git-stitch-repo [ options ] repo1 repo2:dir2 ...

=head1 OPTIONS

    --select < first | last | random >
                 Algorithm for selection the attachment commit
    --no-cached  Disable caching of selected attachement commit

    --help       Print a short online help and exit
    --manual     Print the full manual page and exit
    --version    Print version information and exit

=head1 DESCRIPTION

B<git-stitch-repo> will process the output of C<git-fast-export --all
--date-order> on the git repositories given on the command-line,
and create a stream suitable for B<git-fast-import> that will create
a new repository containing all the commits in a new commit tree
that respects the history of all the source repositories.

Typical usage is like this:

    $ ls
    A  B
    $ mkdir RESULT
    $ cd RESULT
    $ git-init
    $ git-stitch-repo ../A:A ../B:B | git-fast-import

The C<RESULT> repository will contain all commits from repositories A
and B, with the files from A in subdirectory F<A/> and the files from
B in subdirectory F<B/>.

    $ git checkout master-A
    warning: You appear to be on a branch yet to be born.
    warning: Forcing checkout of master-A.
    Switched to branch "master-A"
    $ git checkout master-B
    Switched to branch "master-B"

Both branches can be seen using C<gitk --all>. It is now possible to
create the I<master> branch and have it point at the right commit,
and delete the two I<master-A> and I<master-B> branches.

B<git-stich-repo> works perfectly with repositories that have a B<linear>
history (no merges). It has successfully been tested with 16 linear
repositories, and produced the expected result.

The improvements to the stitching algorithm added in version 0.06 should
make is suitable to work with repositories having branches and merges.

=head2 Commit attachement algorithm

B<git-stitch-repo> processes the input commits in B<--date-order>
fashion, and build a graph by attaching the new commit to another
commit of the graph being constructed. It starts from the "original"
parents of the node, and tries do follow the graph as far as possible.

When a commit has several suitable child commits, it needs to make a
selection. There are currently three selection algorithms:

=over 4

=item last

Pick the last child commit, i.e. the most recent one.
This is the default.

=item first

Pick the first child commit, i.e. the oldest one.

=item random

Pick a random child.

=back

=head2 Example

Imagine we have two repositories A and B that we want to stitch into
a repository C so that all the files from A are in subdirectory F<A>
and all the files from B are in subdirectory F<B>.

Note: in the following ASCII art graphs, horizontal order is chronological.

Repository A:

             ,topic      ,master
          ,-A3------A5--A6
         /         /
    A1--A2------A4'

Branch I<master> points to A5 and branch I<topic> points to A3.

Repository B:

                     ,topic  ,master
          ,-B3------B5------B7--B8
         /                 /
    B1--B2------B4------B6'

Branch I<master> points to B8 and branch I<topic> points to B5.

The RESULT repository should preserve chronology, commit relationships and
branches as much as possible, while giving the impression that the
directories F<A/> & F<B/> did live side-by-side all the time.

Assuming additional timestamps not shown on the above graphs
(the commit order is A1, B1, A2, B2, A3, A4, B3, B4, A5, B5, B6, B7, B8, A6),
B<git-stitch-repo> will produce a B<git-fast-import> stream that will
create the following history, depending on the value of B<--select>:

=over 4

=item I<last> (default)

                                         ,topic-B
                          ,-B3----------B5----.
                         /                     \      ,master-B
    A1--B1--A2--B2------A4------B4--A5------B6--B7---B8--A6
                 \                 /                      `master-A
                  `-A3------------'
                     `topic-A

=item I<first>

                      ,---------B4----------B6-.
                     /                          \     ,master-B
    A1--B1--A2--B2--A3------B3------A5--B5------B7---B8--A6
                 \   `topic-A      /     `topic-B         `master-A
                  `-----A4--------'

=item I<random>

In this example, there are only two places where the selection process
is triggered, and there are only two items to choose from each time.
Therefore the I<random> selection algorithm will produce 4 possible
different results.

In addition to the results shown above (C<last+last> and C<first+first>),
we can also obtain the two following graphs:

C<first+last>:

                     ,topic-A                         ,master-B
    A1--B1--A2--B2--A3--------------A5------B6--B7---B8--A6
                 \                 /           /          `master-A
                  `-----A4------B4'     B5----'
                         \             / `topic-B
                          `-B3--------'

C<last+first>:

                                                      ,master-B
    A1--B1--A2--B2------A4------B4----------B6--B7---B8--A6
                 \       \                     /          `master-A
                  \       `-B3------A5--B5----'
                   \               /     `topic-B
                    A3------------'
                     `topic-A

=back

=head1 ALGORITHM AND CONSTRAINTS

Any mathematician will tell you there are many many ways to stitch two
DAG together. This programs tries very hard not to create inconsistent
history with regard to each input repository.

The algorithm used by B<git-stitch-repo> enforce the following rules
when building the resulting repository:

=over 4

=item *

a commit is attached as far as possible in the DAG, starting from the
original parent

=item *

a commit is only attached to another commit in the resulting repository
that has B<exactly> the same ancestors list as the original parent
commits.

=item *

when there are several valid branches to follow when trying to find 
a commit to attach to, use the selection process (I<last> or I<first>
commit (at the time of attachement), or I<random> commit)

=item *

branches starting from the same commit in a source repository will start
from the same commit in the resulting repository (this particular rule
can be lifted: use the I<--no-cached> option)

=back

=head1 BUGS & IMPROVEMENTS

The current implementation can probably be improved, and more options
added. I'm very interested in test repositories that do not give the
expected results.

=head1 SEE ALSO

L<Git::FastExport::Stitch>

=head1 AUTHOR

Philippe Bruhat (BooK), C<< <book@cpan.org> >>.

=head1 ACKNOWLEDGEMENTS

The original version of this script was created as part of my work
for BOOKING.COM, which authorized its publication/distribution
under the same terms as Perl itself.

=head1 COPYRIGHT

Copyright 2008-2009 Philippe Bruhat (BooK), All Rights Reserved.

=head1 LICENSE

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

