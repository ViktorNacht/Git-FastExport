#!/usr/bin/env perl
use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use Git;
use Git::FastExport;
use File::Spec::Functions qw( rel2abs );

our $VERSION = $Git::FastExport::VERSION;

# basic command-line options
GetOptions( \my %option, 'help', 'manual', 'version' )
    or pod2usage( -verbose => 0 );
print "git-stitch-repo version $VERSION\n" and exit if $option{version};
pod2usage( -verbose => 1 ) if $option{help};
pod2usage( -verbose => 2 ) if $option{manual};

my %repo;

# process command-line parameters
my $name = 'A';
while (@ARGV) {
    my ( $repo, $dir ) = split /:/, shift @ARGV, 2;
    $repo = rel2abs($repo);
    $dir ||= '';

    # create an export parser for each repo
    my $parser
        = Git::FastExport->new( Git->repository( Directory => $repo ) );
    $parser->fast_export(qw( --progress=1 --all --date-order ));
    $parser->{mapdir} = $dir;

    # update the %repo hash
    $repo                = $parser->{source};
    $repo{$repo}{repo}   = $repo;
    $repo{$repo}{dir}    = $dir;
    $repo{$repo}{parser} = $parser;
    $repo{$repo}{name}   = $dir || $name;
    $name++;
}

# repositories that we will process
my @repos = values %repo;

my $mark = 1_000_000;    # mark counter in the new repo
my %mark_map;            # map marks in source repos to marks in the new repo

# get the first commits
$_->{commit} = next_commit( $_->{parser} ) for @repos;

# main loop
my $last;
my %commits;
my @heads;
while (@repos) {

    # sort by date
    @repos = sort { $a->{commit}{date} <=> $b->{commit}{date} } @repos;
    my $repo = $repos[0];

    # next commit to dump
    my $commit = $repo->{commit};

    # update marks & dir in files
    for ( @{ $commit->{files} } ) {
        s/^M (\d+) :(\d+)/M $1 :$mark_map{$repo->{repo}}{$2}/;
        if ( my $dir = $repo->{dir} ) {
            s!^(M \d+ :\d+) (.*)!$1 $dir/$2!;    # filemodify
            s!^D (.*)!D $dir/$1!;                # filedelete

            # /!\ quotes may happen - die and fix if needed
            die "Choked on quoted paths in $repo->{repo}! Culprit:\n$_\n"
                if /^[CR] \S+ \S+ /;

            # filecopy | filerename
            s!^([CR]) (\S+) (\S+)!$1 $dir/$2 $dir/$3!;
        }
    }

    # first commit in the old repo linked to latest commit in new repo
    if ( $last && !$commit->{from} ) {
        $commit->{from} = ["from :$last"];
    }

    # update historical information
    my ($id) = $commit->{mark}[0] =~ /:(\d+)/g;
    $last = $id;    # last commit applied
    my $branch = ( split / /, $commit->{header} )[1];
    my $node = $commits{$id} = {
        name     => $id,
        repo     => $repo->{repo},
        branch   => $branch,
        children => [],
        parents  => {},
        merge    => exists $commit->{merge},
        block    => $commit,
    };

    # mark our original source
    $commit->{header} =~ s/$/-$repo->{name}/;

    # this commit's parents
    my @parents = map {/:(\d+)/g} @{ $commit->{from} || [] },
        @{ $commit->{merge} || [] };

    # get the reference parent list used by last_alien_child()
    my $parents = {};
    for my $parent (@parents) {
        for my $repo ( keys %{ $commits{$parent}{parents} } ) {
            $parents->{$repo}{$_} = 1
                for keys %{ $commits{$parent}{parents}{$repo} };
        }
    }

    # map each parent to its last "alien" commit
    my %parent_map = map {
        $_ =>
            last_alien_child( $commits{$_}, $repo->{repo}, $branch, $parents )
            ->{name}
    } @parents;

    # map parent marks
    for ( @{ $commit->{from} || [] }, @{ $commit->{merge} || [] } ) {
        if (m/^(from|merge) /) {
            s/:(\d+)/:$parent_map{$1}/g;
        }
    }

    # update the parents information
    add_parents( $node => map { $commits{ $parent_map{$_} } } @parents );

    # dump the commit
    print $commit->as_string;

    # update currents heads information
    @heads = grep { !@{ $_->{children} } } @heads, $commits{ $node->{name} };

    # merge alien heads if possible
    if ( @heads > 1 ) {
        my %merged;
        for my $head (@heads) {
            for my $other ( grep { $_->{repo} ne $head->{repo} } @heads ) {

                # already merged?
                my $key = join '-', sort $head->{name}, $other->{name};
                next if $merged{$key};

                # parents of $head in $head's repo contains
                # all parents of $other in $head's repo
                next
                    if grep { !exists $head->{parents}{ $head->{repo} }{$_} }
                        keys %{ $other->{parents}{ $head->{repo} } };

                # parents of $other in $other's repo contains
                # all parents of $head in $other's repo
                next
                    if
                    grep { !exists $other->{parents}{ $other->{repo} }{$_} }
                        keys %{ $head->{parents}{ $other->{repo} } };

                # we can create a new merge commit
                # merging $head and $other
                my $merge = merge_commit( $head, $other );
                $merged{$key}++;
                print $merge->as_string;
            }
        }
    }

    # load next commit
    $repo->{commit} = next_commit( $repo->{parser} )
        or shift @repos;    # no more blocks in this export
}

# return the next commit
# - print out the intermediate blocks
# - offset the old marks
sub next_commit {
    my ($parser) = @_;
    my $block;

    while ( $block = $parser->next_block() ) {

        # map to the new mark
        for ( @{ $block->{mark} || [] } ) {
            s/:(\d+)/:$mark/
                and $mark_map{ $parser->{source} }{$1} = $mark++;
        }

        # update marks in from & merge
        for ( @{ $block->{from} || [] }, @{ $block->{merge} || [] } ) {
            if (m/^(from|merge) /) {
                s/:(\d+)/:$mark_map{$parser->{source}}{$1}/g;
            }
        }
        last if $block->{type} eq 'commit';
        print $block->as_string();
    }
    return $block;
}

# create a new merge commit
# update the global %commits database
# return a Git::FastExport::Block object
sub merge_commit {
    my (@commits) = @_;

    # add the new node to the commit database
    my $merge = {
        name     => $mark++,
        repo     => '',        # no repo
        branch   => '',        # no branch
        children => [],        # no children yet
        parents  => {},
        merge    => 1,         # this is a merge commit
    };
    add_parents( $merge => @commits );

    # create the corresponding Git::FastExport::Block object
    my $author = 'git-stitch-repo <> ' . time . ' +0000';
    $merge->{block} = bless {
        type      => 'commit',
        header    => 'commit ref/heads/master',
        mark      => ["mark :$merge->{name}"],
        author    => ["author $author"],
        committer => ["committer $author"],
        from      => ["from :$commits[0]{name}"],
        merge     => ["merge :$commits[1]{name}"],
        files     => [ map { @{ $commits[$_]{block}{files} } } 0, 1 ],
        data      => "merge commit added by git-stitch-repo\n",
        },
        'Git::FastExport::Block';

    # update the commit database
    $commits{ $merge->{name} } = $merge;

    # return the Git::FastExport::Block object
    return $merge->{block};
}

# given a commit (item from %commits)
# add the parents from the given commits to it
sub add_parents {
    my ( $node, @parents ) = @_;

    for my $parent (@parents) {
        push @{ $parent->{children} }, $node->{name};
        for my $repo_name ( keys %{ $parent->{parents} } ) {
            $node->{parents}{$repo_name}{$_} = 1
                for keys %{ $parent->{parents}{$repo_name} || {} };
        }
        $node->{parents}{ $parent->{repo} }{ $parent->{name} } = 1;
    }

    return $node;
}

# find the last child of this node
# that has either no child
# or a child in our repo
# or an alien child that has the same parent list
sub last_alien_child {
    my ( $node, $repo, $branch, $parents ) = @_;
    my $old = '';

    while ( $node ne $old ) {
        $old = $node;

        # no children nodes
        return $node if ( !@{ $node->{children} } );

        # some children nodes are local
        return $node
            if grep { $commits{$_}{repo} eq $repo } @{ $node->{children} };

        # all children are alien to us
        for my $peer ( @{ $node->{children} } ) {

            # the child parent list
            my $peer_parents = join( ',',
                sort keys
                    %{ $commits{$peer}{parents}{ $commits{$peer}{repo} } } );

            # the valid parent list for the node we want to attach
            my $ref_parents = join( ',',
                sort keys %{ $parents->{ $commits{$peer}{repo} } } );

            next if $commits{$peer}->{merge} && $peer_parents ne $ref_parents;

            # this child node has a valid parent list
            $node = $commits{$peer};
            last;    # stop at the first we find
        }
    }

    # return last valid child
    return $node;
}

__END__

=head1 NAME

git-stitch-repo - Stitch several git repositories into a git-fast-import stream

=head1 SYNOPSIS

git-stitch-repo repo1 repo2:dir2 ...

=head1 OPTIONS

    --help       Print a short online help and exit
    --manual     Print the full manual page and exit
    --version    Print version information and exit

=head1 DESCRIPTION

B<git-stitch-repo> will process the output of C<git-fast-export --all
--date-order> on the git repositories given on the command-line,
and create a stream suitable for B<git-fast-import> that will create
a new repository containing all the commits in a new commit tree
that respects the history of all the source repositories.

Typical usage is like this:

    $ ls
    A  B
    $ mkdir RESULT
    $ cd RESULT
    $ git-init
    $ git-stitch-repo ../A:A ../B:B | git-fast-import

The C<RESULT> repository will contain all commits from repositories A
and B, with the files from A in subdirectory F<A/> and the files from
B in subdirectory F<B/>.

    $ git checkout master-A
    warning: You appear to be on a branch yet to be born.
    warning: Forcing checkout of master-A.
    Switched to branch "master-A"
    $ git checkout master-B
    Switched to branch "master-B"

Both branches can be seen using C<gitk --all>. It is now possible to
create the I<master> branch and have it point at the right commit,
and delete the two I<master-A> and I<master-B> branches.

B<git-stich-repo> works perfectly with repositories that have a B<linear>
history (no merges). It has successfully been tested with 16 linear
repositories, and produced the expected result.

=head2 Example

Imagine we have two repositories A and B that we want to stitch into
a repository C so that all the files from A are in subdirectory F<A>
and all the files from B are in subdirectory F<B>.

Note: in the following ASCII art graphs, horizontal order is chronological.

Repository A:

                topic
                '    ,master
          ,----A3---A5
         /         /
    A1--A2---A4---'

Branch I<master> points to A5 and branch I<topic> points to A3.

Repository B:

                           ,topic    ,master
           ,---------B3---B5---B7---B8
          /                   /
    B1---B2---B4---B6--------'

Branch I<master> points to B8 and branch I<topic> points to B5.

The RESULT repository should preserve chronology, commit relationships and
branches as much as possible, while giving the impression that the
directories F<A/> & F<B/> did live side-by-side all the time.

Assuming additional timestamps not shown on the above graphs,
B<git-stitch-repo> will produce a B<git-fast-import> stream that will
create the following history:

                                       ,topic-A
                      ,---------------A3---B3 master-A
                     /                      \ '    ,topic-B
                    /         ,--------------A5---B5
                   /         /                     \      ,master-B
   A1---B1---A2---B2---A4---B4---B6-----------------B7---B8


=head1 BUGS & IMPROVEMENTS

Any mathematician will tell you there are many many ways to stitch two
trees together. This programs tries very hard not to create inconsistent
history with regard to each input repository.

The current implementation can (and will be) improved. I'm very interested
in test repositories that do not give the expected results.

One of the issues is that we currently refuse to stitch a node after
a merge from another repository. For the current example, that would
mean that any commit having A5 as a parent would be attached to B5,
and not to B8.

Fixing this is in the TODO list.

=head1 AUTHOR

Philippe Bruhat (BooK), C<< <book@cpan.org> >>.

=head1 ACKNOWLEDGEMENTS

The original version of this script was created as part of my work
for BOOKING.COM, which authorized its publication/distribution
under the same terms as Perl itself.

=head1 COPYRIGHT

Copyright 2008 Philippe Bruhat (BooK), All Rights Reserved.

=head1 LICENSE

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

