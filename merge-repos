#!/usr/bin/env perl
use strict;
use warnings;
use File::Basename;
use lib dirname($0) . '/lib';
use Git::Export;
use List::Util qw( min max );

my %repo;

die "Odd number of parameters\nUsage: merge-repos [ repo dir ] ...\n"
    if @ARGV % 2;

# process command-line parameters
while (@ARGV) {
    my ( $repo, $dir ) = splice( @ARGV, 0, 2 );
    $repo{$repo}{dir}  = $dir;
    $repo{$repo}{repo} = $repo;
}

# create an export parser for each repo
for my $repo ( keys %repo ) {
    my $parser = Git::Export->new();
    $parser->fast_export( $repo{$repo}{repo} );
    $repo{$repo}{parser} = $parser;
}

# repositories that we will process
my @repos = values %repo;

my $mark = 1_000_000;    # mark counter in the new rpo
my %mark_map;            # map marks in source repos to marks in the new repo

# get the first commits
$_->{commit} = next_commit( $_->{parser} ) for @repos;

# main loop
use Data::Dumper;
my @commits;
while (@repos) {

    # sort by date
    @repos = sort { $a->{commit}{date} <=> $b->{commit}{date} } @repos;
    my $repo = $repos[0];

    # next commit to dump
    my $commit = $repo->{commit};

    # update marks in from & merge
    for (@{ $commit->{from} || [] }, @{ $commit->{merge} || [] }) {
        if (m/^(from|merge) /){
            s/:(\d+)/:$mark_map{$repo->{repo}}{$1}/g;
        }   
    }
    
    # update marks & dir in files
    for ( @{ $commit->{files} } ) {
        s/^M (\d+) :(\d+)/M $1 :$mark_map{$repo->{repo}}{$2}/;
        if ( my $dir = $repo->{dir} ) {
            s!^(M \d+ :\d+) (.*)!$1 $dir/$2!;    # filemodify
            s!^D (.*)!D $dir/$1!;                # filedelete

            # /!\ quotes may happen - die and fix if needed
            die "Choked on quoted paths in $repo->{repo}! Culprit:\n$_\n"
                if /^[CR] \S+ \S+ /;

            # filecopy | filerename
            s!^([CR]) (\S+) (\S+)!$1 $dir/$2 $dir/$3!;
        }
    }

    # first commit in the old repo linked to latest commit in new repo
    if ( @commits && !$commit->{from} ) {
        $commit->{from} = [ 'from :' . max @commits ];
    }

    # dump the commit
    print $commit->as_string;
    push @commits, $commit->{mark}[0] =~ /:(\d+)/g;

    # load next commit
    $repo->{commit} = next_commit( $repo->{parser} )
        or shift @repos;    # no more blocks in this export
}

# return the next commit
# - print out the intermediate blocks
# - offset the old marks
sub next_commit {
    my ($parser) = @_;
    my $block;

    while ( $block = $parser->next_block() ) {

        # map to the new mark
        if ( $block->{mark} ) {
            for ( @{ $block->{mark} } ) {
                s/:(\d+)/:$mark/;
                $mark_map{ $parser->{source} }{$1} = $mark;
            }
            $mark++;
        }
        last if $block->{type} eq 'commit';
        print $block->as_string();
    }
    return $block;
}

